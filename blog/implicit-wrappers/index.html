<!doctype html><html lang=en-us><head>
<meta charset=utf-8>
<title>Making Your Wrappers Better with Implicit Operators</title>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name=author content="Carson Tolleshaug">
<meta name=generator content="Hugo 0.88.1">
<link rel=stylesheet href=https://carson.tolleshaug.org/css/bootstrap.min.css>
<link rel=stylesheet href=https://carson.tolleshaug.org/font-awesome/css/font-awesome.min.css>
<link href=https://carson.tolleshaug.org/scss/style.min.css rel=stylesheet>
<link rel="shortcut icon" href=https://carson.tolleshaug.org/images/favicon.svg type=image/x-icon>
<link rel=icon href=https://carson.tolleshaug.org/images/favicon.svg type=image/x-icon>
</head><body><nav class="navbar navbar-expand-lg site-navigation">
<div class=container>
<a class=navbar-brand href=https://carson.tolleshaug.org/>
<img src=https://carson.tolleshaug.org/images/logo.svg alt=logo>
<span class=navbar-title>Carson Tolleshaug</span>
</a>
<button class="navbar-toggler collapsed" type=button data-toggle=collapse data-target=#sitenavbar>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<div class="collapse navbar-collapse" id=sitenavbar>
<ul class="navbar-nav ml-auto main-nav">
<li class=nav-item>
<a class=nav-link href=https://carson.tolleshaug.org/>Home</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://carson.tolleshaug.org/about>About</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://carson.tolleshaug.org/blog>Blog</a>
</li>
<li class=nav-item>
<a class=nav-link href=https://carson.tolleshaug.org/portfolio>Projects</a>
</li>
</ul>
</div>
</div>
</nav>
<main>
<section class="site-blog details">
<div class=container>
<div class="row justify-content-center">
<div class=col-lg-8>
<article class=site-blog-details>
<p><span>August 24, 2021</span></p>
<h2 class=blog-title>Making Your Wrappers Better with Implicit Operators</h2>
<ul class=blog-tags>
<li><a href=/tags/c%23/>C#</a></li>
<li><a href=/tags/object-oriented-design/>Object-Oriented Design</a></li>
</ul>
<img class=feature-image src=https://carson.tolleshaug.org/images/blog/details-implicit-wrappers.jpg alt=blog-feature-image>
<p class=blog-tldr><span class=tldr-title>TLDR;</span><span class=tldr-content>Implicit operators are cool, and you should use them in your wrapper classes.</span></p>
<p>First off, if you don&rsquo;t know what a &ldquo;wrapper&rdquo; class is, you&rsquo;re doing it wrong. But, just to make
sure we&rsquo;re on the same page, I&rsquo;ll define it as follows:</p>
<blockquote>
<p>A &ldquo;wrapper&rdquo; is a class who&rsquo;s sole purpose is to encapsulate external functionality while providing
an interface for dependent classes to consume. This allows the dependent classes to be more test-able,
and simultaneously decouples internal code from external library implementation.</p>
</blockquote>
<p>Clear as mud? Great. Let&rsquo;s get to the good part.</p>
<h3 id=wrapper-instantiation>Wrapper Instantiation</h3>
<p>It&rsquo;s common to see wrapper classes in C# instantiated like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#>ExternalConcreteClass externalClass = <span style=color:#66d9ef>new</span> ExternalConcreteClass();
IMyWrappedInterface myVar = <span style=color:#66d9ef>new</span> MyWrappedClass(externalClass);

<span style=color:#66d9ef>string</span> result = DoStuff(myVar);
</code></pre></div><p>Here we create an instance of <code>MyWrappedClass</code> which implements the <code>IMyWrappedInterface</code> interface, but
in order to do so we first had to create and then pass in an instance of the external concrete class which
comes from outside our code.</p>
<p>Granted, instantiation is usually done in either chained constructors, or in a dependency injection
framework, but I&rsquo;ve made everything inline so it&rsquo;s more clear.</p>
<p>The implementation for <code>MyWrappedClass</code> would look something like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyWrappedClass</span> : IMyWrappedInterface
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ExternalConcreteClass <span style=color:#ae81ff>_</span>instance;

    <span style=color:#66d9ef>public</span> MyWrappedClass(ExternalConcreteClass instance)
    {
        <span style=color:#ae81ff>_</span>instance = instance;
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> MyWrappedMethod() =&gt; <span style=color:#ae81ff>_</span>instance.MyMethod();
}
</code></pre></div><h3 id=what-if-i-told-you-theres-a-better-way>What if I told you, there&rsquo;s a better way?</h3>
<p>For us C# devs, we can improve this code by using
<a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators>implicit operators</a>.
Take a look at the following change to <code>MyWrappedClass</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyWrappedClass</span> : IMyWrappedInterface
{
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ExternalConcreteClass <span style=color:#ae81ff>_</span>instance;

    <span style=color:#66d9ef>public</span> MyWrappedClass(ExternalConcreteClass instance)
    {
        <span style=color:#ae81ff>_</span>instance = instance;
    }

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> MyWrappedMethod() =&gt; <span style=color:#ae81ff>_</span>instance.MyMethod();

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>operator</span> MyWrappedClass(ExternalConcreteClass e) =&gt; <span style=color:#66d9ef>new</span> MyWrappedClass(e);
}
</code></pre></div><p>Now we can implicitly convert any instance of <code>ExternalConcreteClass</code> to <code>MyWrappedClass</code>.</p>
<h3 id=so-what>So What?</h3>
<p>Well, check this out. Our original code can be simplified:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#>ExternalConcreteClass externalClass = <span style=color:#66d9ef>new</span> ExternalConcreteClass();

<span style=color:#66d9ef>string</span> result = DoStuff(externalClass);
</code></pre></div><p><strong>It&rsquo;s like it&rsquo;s not even wrapped at all!</strong> ( ͡° ͜ʖ ͡°)</p>
<p>Under the hood, this will implicitly cast our instance of <code>ExternalConcreteClass</code> to an instance of <code>MyWrappedClass</code> before passing it to the <code>DoStuff()</code> method. This conversion happens by calling the implicit operator declaration we gave in our class:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>operator</span> MyWrappedClass(ExternalConcreteClass e) =&gt; <span style=color:#66d9ef>new</span> MyWrappedClass(e);
</code></pre></div><h3 id=useful-example>Useful Example</h3>
<p>If you work with ASP.NET, it can be extremely useful to wrap HTTP related concerns. Here&rsquo;s a standard controller endpoint that uses a service layer to do the actual &ldquo;work&rdquo; for the request:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#a6e22e>[HttpGet]</span>
<span style=color:#66d9ef>public</span> IActionResult Get(<span style=color:#66d9ef>string</span> input)
{
    MyModel result = <span style=color:#ae81ff>_</span>service.GetMyModel(input);

    <span style=color:#66d9ef>return</span> Ok(result);
}
</code></pre></div><p>Let&rsquo;s say you want your service layer to add or modify the cookies of the response. Normally you&rsquo;d wrap the <code>Request</code> object like this:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#a6e22e>[HttpGet]</span>
<span style=color:#66d9ef>public</span> IActionResult Get(<span style=color:#66d9ef>string</span> input)
{
    IResponseWrapper responseWrapper = <span style=color:#66d9ef>new</span> ResponseWrapper(<span style=color:#66d9ef>this</span>.HttpContext.Response)

    MyModel result = <span style=color:#ae81ff>_</span>service.GetMyModel(input, responseWrapper);

    <span style=color:#66d9ef>return</span> Ok(result);
}
</code></pre></div><p>Now let&rsquo;s add an implicit conversion to our wrapper:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>operator</span> ResponseWrapper(System.Web.HttpRequest request) =&gt; <span style=color:#66d9ef>new</span> ResponseWrapper(request);
</code></pre></div><p>We don&rsquo;t need to make any changes to our service layer at all and the controller code now becomes:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=color:#a6e22e>[HttpGet]</span>
<span style=color:#66d9ef>public</span> IActionResult Get(<span style=color:#66d9ef>string</span> input)
{
    MyModel result = <span style=color:#ae81ff>_</span>service.GetMyModel(input, <span style=color:#66d9ef>this</span>.HttpContext.Response);

    <span style=color:#66d9ef>return</span> Ok(result);
}
</code></pre></div><p>By using implicit conversion in our wrapper class, we make the code cleaner and more readable without sacrificing testability or functionality of our dependent classes. The service layer can continue to depend on an interface that can easily be mocked or faked, but the controller doesn&rsquo;t need to worry about creating objects.</p>
<p>Hopefully, you can see why I think this is so cool. Have Fun!</p>
</article>
</div>
</div>
</div>
</section>
</main><footer class=site-footer>
<div class=container>
<div class=row>
<div class="col-12 col-center">
<div class=site-footer-logo><a href=https://carson.tolleshaug.org/><img src=https://carson.tolleshaug.org/images/logo-white.svg alt=logo-footer></a></div>
<div class=site-footer-social>
<ul class=icons>
<li><a target=_blank href=https://github.com/CarsonTolleshaug><i class="fa fa-github"></i></a></li>
<li><a target=_blank href=https://www.linkedin.com/in/carson-tolleshaug><i class="fa fa-linkedin"></i></a></li>
<li><a target=_blank href=mailto:carson.tolleshaug@gmail.com><i class="fa fa-envelope"></i></a></li>
</ul>
<p>Carson Tolleshaug &copy; 2021</p>
</div>
</div>
</div>
</div>
</footer>
<script src=https://carson.tolleshaug.org/js/formhandler.min.js></script>
<script src=https://carson.tolleshaug.org/js/vendor.min.js></script>
<script src=https://carson.tolleshaug.org/js/script.min.js></script></body>
</html>